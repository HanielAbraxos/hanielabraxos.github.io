console.clear(),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=Array.prototype.forEach);class ScreenFilter extends PIXI.Filter{constructor(e){super(PIXI.Filter.defaultVertexSrc,ScreenFilter.fragmentSrc),this.resolution=e,this.uniforms.time=0,this.uniforms.mouse=[0,0],this.uniforms.u_resolution=[window.innerWidth*this.resolution,window.innerHeight*this.resolution],this.uniforms.ratio=this.uniforms.u_resolution[1]<this.uniforms.u_resolution[0]?this.uniforms.u_resolution[0]/this.uniforms.u_resolution[1]:this.uniforms.u_resolution[1]/this.uniforms.u_resolution[0],this.autoFit=!1,this.onResize=this.onResize.bind(this),window.addEventListener("resize",this.onResize)}onResize(){this.uniforms.u_resolution=[window.innerWidth*this.resolution,window.innerHeight*this.resolution],this.uniforms.ratio=this.uniforms.u_resolution[1]<this.uniforms.u_resolution[0]?this.uniforms.u_resolution[0]/this.uniforms.u_resolution[1]:this.uniforms.u_resolution[1]/this.uniforms.u_resolution[0]}static get fragmentSrc(){return"\n  /*\n    Sceen distortion filter\n    -------------------\n    \n    This shader expects to operate on a screen sized container (essentailly the whole menu)\n    and take the output of the program and distort it in a radial pattern, applying some\n    bloomed blur and noisy waves toward the edge, centered on the mouse.\n\n  */  \n  precision highp float;\n  varying vec2 vTextureCoord;\n\n  uniform sampler2D uSampler;\n  uniform vec4 inputClamp;\n  uniform vec4 inputSize;\n  uniform vec4 inputPixel;\n  uniform vec4 outputFrame;\n  uniform vec2 mouse;\n  uniform vec2 u_resolution;\n  uniform float ratio;\n  uniform float time;\n\n  #define PI 3.14159265359\n  \n  // Return a random number between 0 and 1 based on a vec2\n  float rand(vec2 c){\n\t  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n  }\n\n  // This is sort of a cheap and dirty precursor to full on\n  // Perlin noise. We could have happily used a more expensive\n  // noise algorithm here, but this is more than sufficient \n  // for our needs.\n  float noise(vec2 p, float freq ){\n    float unit = inputSize.x/freq;\n    vec2 ij = floor(p/unit);\n    vec2 xy = mod(p,unit)/unit;\n    //xy = 3.*xy*xy-2.*xy*xy*xy;\n    xy = .5*(1.-cos(PI*xy));\n    float a = rand((ij+vec2(0.,0.)));\n    float b = rand((ij+vec2(1.,0.)));\n    float c = rand((ij+vec2(0.,1.)));\n    float d = rand((ij+vec2(1.,1.)));\n    float x1 = mix(a, b, xy.x);\n    float x2 = mix(c, d, xy.x);\n    return mix(x1, x2, xy.y);\n  }\n\n  // Blur a texture based on a 7 sample laplacian\n  // Fast gaussien blur - https://github.com/Jam3/glsl-fast-gaussian-blur\n  vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n    vec4 color = vec4(0.0);\n    vec2 off1 = vec2(1.411764705882353) * direction;\n    vec2 off2 = vec2(3.2941176470588234) * direction;\n    vec2 off3 = vec2(5.176470588235294) * direction;\n    color += texture2D(image, uv) * 0.1964825501511404;\n    color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n    color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n    color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n    color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n    color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n    color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n    return color;\n  }\n\n  void main(void){\n    // Generate our normalized, centered UV coordinates\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);\n    // Get the mouse coordinates in relation to the frament coords\n    vec2 uvm = uv - mouse;\n    uvm /= ratio;\n    // The radial mouse gradient. We use this to apply our blur\n    vec2 raidalmouse = smoothstep(.3, 2., abs(uvm) * 2.);\n\n    // Initialise our texture output\n    vec4 tex = vec4(0.);\n\n    // The centered texture coordinates\n    vec2 textureCoord = vTextureCoord - .5;\n    // The polar texture coordinates\n    vec2 polar = vec2(length(textureCoord), atan(textureCoord.y,textureCoord.x));\n    // This distorts the texture in a wave pattern around our mouse position.\n    polar.y += smoothstep(.1, 2., abs(uvm.x) * 2.);\n    // polar.y += smoothstep(.1, 2., abs(uvm.x) * 4.); // uncomment this to see the effects of ramping up the mouse vector\n    // This is just converting our polar texture coordinates back into cartesian coordinates\n    textureCoord = vec2( cos(polar.y) * polar.x, sin(polar.y) * polar.x );\n\n    // This just increases the size of the text slightly as it gets further from the middle of the mouse position\n    // Essentially this is multiplying texture in the Y direction based on the distance from the centre of the mouse\n    textureCoord.y *= 1. - abs(uvm.x * 1.5) * .3;\n    // textureCoord *= 1. - smoothstep(.2, .5, length(uvm)) * .3; // Uncomment this line to ramp up this effect\n\n    // Now, the good stuff!\n    // Add some noise to the texture coordinate (with a time component, naturally) and \n    // multiply the effect by a gradient centered on the mouse's position.\n    textureCoord += noise(uv, 10000. + sin(time) * 5000.) * smoothstep(.15, 2., abs(uvm.x)) * .6;\n    // This just recenters the coordinate\n    textureCoord += .5;\n\n    // Gather the blur samples build the texture\n    //tex = blur13(uSampler, textureCoord, u_resolution, vec2(clamp(raidalmouse.x*20., 0., 5.), 0.));\n    //tex += blur13(uSampler, textureCoord, u_resolution, vec2(0., clamp(raidalmouse.x*20., 0., 5.)));\n    //tex *= .5;\n\n    // If you want to get rid of the blur, use the below instead of the above, it will just spit out the \n    // exact texture based on all of the above\n    tex = texture2D(uSampler, textureCoord);\n\n    // assemble the colour based on the texture multiplied by a gradient of the mouse position - this \n    // just fades the texture out at the edges\n    gl_FragColor = tex * 1. - smoothstep(.5, 1.5, length(uvm)*2.);\n\n    // Uncomment the below to output the combination of the blurred, distorted texture and a gradient\n    // representing the mouse position\n    // gl_FragColor = vec4(vec3(1. - smoothstep(.2, .25, length(uvm)) * .3), 1.);\n    // gl_FragColor = mix(gl_FragColor, tex, tex.a);\n  }\n"}apply(e,t,n){this.uniforms.time+=.01,e.applyFilter(this,t,n)}set mousepos(e){e instanceof Array&&2===e.length&&!isNaN(e[0])&&!isNaN(e[1])&&(this._mousepos=e,this.uniforms.mouse=e)}get mousepos(){return this._mousepos||[0,0]}}class HoverFilter extends PIXI.Filter{constructor(){super(PIXI.Filter.defaultVertexSrc,HoverFilter.fragmentSrc),this.uniforms.time=0}static get fragmentSrc(){return"\n  /*\n    Hover filter\n    -------------------\n    \n    This shader expects to operate on a display object within a pixi application.\n    It takes the output of the display object and applies some noise to it based\n    on the objects alpha channel, in this way clamping the colour to the bounts\n    of the text that makes up the button\n\n  */  \n  precision highp float;\n  varying vec2 vTextureCoord;\n\n  uniform sampler2D uSampler;\n  uniform vec4 inputClamp;\n  uniform vec4 inputSize;\n  uniform vec4 inputPixel;\n  uniform vec4 outputFrame;\n  uniform float time;\n\n  #define PI 3.14159265359\n  \n  // Return a random number between 0 and 1 based on a vec2\n  float rand(vec2 c){\n\t  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n  }\n\n  // Some FBM noise based on a value component\n  // see https://thebookofshaders.com/13/ for more details\n  #define NUM_OCTAVES 3\n  float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\n  vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\n  vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n  float noise(vec3 p){\n      vec3 a = floor(p);\n      vec3 d = p - a;\n      d = d * d * (3.0 - 2.0 * d);\n\n      vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n      vec4 k1 = perm(b.xyxy);\n      vec4 k2 = perm(k1.xyxy + b.zzww);\n\n      vec4 c = k2 + a.zzzz;\n      vec4 k3 = perm(c);\n      vec4 k4 = perm(c + 1.0);\n\n      vec4 o1 = fract(k3 * (1.0 / 41.0));\n      vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n      vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n      vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n      return o4.y * d.y + o4.x * (1.0 - d.y);\n  }\n  float fbm(vec3 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n      v += a * noise(x);\n      x = x * 2.0 + shift;\n      a *= 0.5;\n    }\n    return v;\n  }\n\n  float distortedFBM(in vec3 x) {\n    float t = fbm(x);\n    x.xy += (t -.5);\n    t *= fbm(x);\n    x.xy += (t -.5) * .6;\n    t = fbm(x);\n    return t;\n  }\n\n  // Create a pattern based on a normalised uv coordinate. In this\n  // example we're making some noise and setting a couple of colours,\n  // but you could make this any sort of pattern\n  vec4 pattern(vec2 uv) {\n\n    // Increasing the frequency of the noise\n    uv *= 4.;\n    // modify our time component, making it faster\n    float t = time*2.;\n\n    // Create our noise\n\n    float pattern = distortedFBM(vec3(uv, t));\n    pattern *= pattern * 1.2;\n    // Create our base colour\n    vec4 rtn = vec4( 0.81, 0.33, 0, 1. ); // dark blue\n    // mux this colour with another based on the noise value\n    rtn = mix(rtn, vec4( 1. ), smoothstep(.0, 1., pattern)); // sort of a light light grey colour\n    return rtn;\n    \n  }\n\n  void main(void){\n    // Generate our normalized, centered UV coordinates\n    vec2 uv = (gl_FragCoord.xy - 0.5 * inputSize.xy) / min(inputSize.x, inputSize.y);\n    // Get the base texture - this is the display object from pixi\n    vec4 tex = texture2D(uSampler, vTextureCoord);\n\n    // output the pattern constrained by the texture's alpha\n    gl_FragColor = vec4((tex.a) * pattern(uv));\n  }\n"}apply(e,t,n){this.uniforms.time+=.01,e.applyFilter(this,t,n)}}class Navigation{constructor(e){this.nav=e,this.initialised=!1,this.navItems=[],this.app=null,this.container=null,this.screenFilter=null,this.navWidth=null,this.background=null,this.pointerdown=!1,this.dragging=!1,this.targetMousePos=[0,0],this.onPointerMove=this.onPointerMove.bind(this),this.onPointerDown=this.onPointerDown.bind(this),this.onPointerUp=this.onPointerUp.bind(this),this.onResize=this.onResize.bind(this),this.onOpen=this.onOpen.bind(this),this.onClose=this.onClose.bind(this),this.animate=this.animate.bind(this)}init(){this.initialised=!0;this.nav.querySelectorAll("a").forEach((e=>{this.navItems.push({rootElement:e,title:e.innerText,element:null,sprite:null,link:e.href})})),this.makeNavItems(),this.setupWebGLContext(),window.addEventListener("pointermove",this.onPointerMove),window.addEventListener("pointerdown",this.onPointerDown),window.addEventListener("pointerup",this.onPointerUp),window.addEventListener("resize",this.onResize),window.addEventListener("navOpen",this.onOpen),window.addEventListener("navClose",this.onClose)}makeNavItems(){this.initialised&&this.navItems.forEach(((e,t)=>{e.element=this.makeNavItem(e.title,e.link),e.sprite=PIXI.Sprite.from(e.element),e.sprite.interactive=!0,e.sprite.buttonMode=!0;const n=new HoverFilter;e.rootElement.addEventListener("focus",(()=>{this.focusNavItemByIndex(t),e.sprite.filters=[n]})),e.rootElement.addEventListener("blur",(()=>{e.sprite.filters=[]})),e.sprite.on("pointerover",(t=>{e.sprite.filters=[n]})),e.sprite.on("pointerout",(t=>{e.sprite.filters=[]})),e.sprite.on("pointerup",(t=>{this.dragging||e.rootElement.click()}))}))}makeNavItem(e){if(!this.initialised)return;const t=document.createElement("canvas"),n=t.getContext("2d"),i="tenez";return n.font=`400 80px ${i}`,t.width=n.measureText(e).width+50,t.height=120,n.font=`400 80px ${i}`,n.textAlign="center",n.textBaseline="bottom",n.fillStyle="rgba(223,143,86,1)",n.fillText(e,.5*t.width,t.height-16),t}setupWebGLContext(){if(!this.initialised)return;this.app=new PIXI.Application({backgroundColor:this.backgroundColour,width:window.innerWidth,height:window.innerHeight,resolution:2}),this.app.stage.x=.5*window.innerWidth,this.app.stage.y=.5*window.innerHeight,this.container=new PIXI.Container,this.screenFilter=new ScreenFilter(2),this.app.stage.filters=[this.screenFilter];let e=0;this.navWidth=0,this.navItems.forEach((e=>{this.navWidth+=e.sprite.width})),this.navItems.forEach((t=>{t.sprite.x=-.5*this.navWidth+e,e+=t.sprite.width,this.container.addChild(t.sprite)})),this.background=new PIXI.Graphics,this.setupBackground(),this.app.stage.addChild(this.background),this.app.stage.addChild(this.container),this.app.view.setAttribute("aria-hidden","true"),this.app.view.setAttribute("tab-index","-1"),this.app.view.className="w-main-nav__canvas",this.nav.appendChild(this.app.view)}focusNavItemByIndex(e){if(!this.initialised)return;let t=0;this.navItems.forEach(((n,i)=>{let o=n.element.width/this.navWidth;i<e?t+=o:i===e&&(t+=.5*o)}));let n=[.1*window.innerWidth+.8*window.innerWidth*t,.5*window.innerHeight];this.mousepos=n}deInit(){window.removeEventListener("pointermove",this.onPointerMove),window.removeEventListener("pointerdown",this.onPointerDown),window.removeEventListener("pointerup",this.onPointerUp),window.removeEventListener("resize",this.onResize)}setupBackground(){if(!this.initialised)return;this.background.clear(),this.background.beginFill(this.backgroundColour,0),this.background.position.x=-.5*window.innerWidth,this.background.position.y=-.5*window.innerHeight,this.background.drawRect(-this.maskpadding,-this.maskpadding,window.innerWidth+this.maskpadding,window.innerHeight+this.maskpadding),this.background.endFill();const e=new PIXI.Graphics;e.beginFill(this.backgroundColour,.5),e.position.x=-.5*window.innerWidth,e.position.y=-.5*window.innerHeight,e.drawRect(-this.maskpadding,-this.maskpadding,window.innerWidth+this.maskpadding,window.innerHeight+this.maskpadding),e.endFill(),this.container.mask=e}fixMousePos(e){let t=window.innerHeight/window.innerWidth,n=[];return window.innerHeight>window.innerWidth?(n[0]=(e[0]-window.innerWidth/2)/window.innerWidth,n[1]=(e[1]-window.innerHeight/2)/window.innerHeight*-1*t):(n[0]=(e[0]-window.innerWidth/2)/window.innerWidth/t,n[1]=(e[1]-window.innerHeight/2)/window.innerHeight*-1),n}unfixMousePos(e){let t=window.innerHeight/window.innerWidth,n=[];return window.innerHeight>window.innerWidth?(n[0]=e[0]*window.innerWidth+window.innerWidth/2,n[1]=e[1]*window.innerHeight/-1/t+window.innerHeight/2):(n[0]=e[0]*window.innerWidth*t+window.innerWidth/2,n[1]=e[1]*window.innerHeight/-1+window.innerHeight/2),n}onResize(e){this.app.renderer.resize(window.innerWidth,window.innerHeight),this.app.stage.x=.5*window.innerWidth,this.app.stage.y=.5*window.innerHeight,this.setupBackground()}onPointerMove(e){!0!==this.animatingPointer?(this.dragging||"mouse"===e.pointerType)&&(this.mousepos=[e.pageX,e.pageY]):(this.dragging||"mouse"===e.pointerType)&&(this.targetMousePos=[e.pageX,e.pageY])}onPointerDown(e){this.pointerdown=!0,setTimeout((()=>{!0===this.pointerdown&&(this.dragging=!0)}),300)}onPointerUp(e){this.pointerdown=!1,setTimeout((()=>{this.dragging=!1}),300)}onOpen(){this.animatingPointer=!0,this.focusNavItemByIndex(0),this.targetMousePos=this.unfixMousePos(this.mousepos),this.mousepos=[3e3,.5*window.innerHeight]}onClose(){this.animatingPointer=!1}animate(e){!0===this.animatingPointer&&requestAnimationFrame(this.animate);const t=this.unfixMousePos(this.mousepos),n=[this.targetMousePos[0]-t[0],this.targetMousePos[1]-t[1]];t[0]+=.05*n[0],t[1]+=.05*n[1],this.mousepos=t}set backgroundColour(e){const t=/^#([0-9ABCDEF]{6,6})/i.exec(e);"string"==typeof e&&null!=t?this._backgroundColour=1*`0x${t[1]}`:"number"==typeof e&&(this._backgroundColour=e),this.setupBackground()}get backgroundColour(){return this._backgroundColour||1381653}set animatingPointer(e){const t=this.animatingPointer;this._animating=!0===e,!1===t&&!0===this.animatingPointer&&requestAnimationFrame(this.animate)}get animatingPointer(){return this._animating||!1}set dragging(e){!0===e?(this.old_animatingPointer=this.animatingPointer,this.animatingPointer=!1,this._dragging=!0):this._dragging=!1}get dragging(){return this._dragging||!1}set mousepos(e){const t=e[0]/window.innerWidth;this.container.position.x=-.5*this.navWidth+(1-t)*this.navWidth,(e=this.fixMousePos(e))instanceof Array&&2===e.length&&!isNaN(e[0])&&!isNaN(e[1])&&(this._mousepos=e,this.screenFilter&&(this.screenFilter.mousepos=e))}get mousepos(){return this._mousepos||[0,0]}set maskpadding(e){isNaN(e)||(this._maskpadding=e)}get maskpadding(){return isNaN(this._maskpadding)?100:this._maskpadding}}const navToggle=document.getElementById("w-main-nav-toggle");document.addEventListener("keyup",(e=>{!e.target.className.indexOf("w-nav-toggle")||13!==e.keyCode&&32!==e.keyCode||(navToggle.checked=!navToggle.checked,e.preventDefault())})),navToggle.addEventListener("change",(e=>{let t;if(console.log(e.target.checked),t=e.target.checked?"navOpen":"navClose",window.CustomEvent)var n=new CustomEvent(t);else(n=document.createEvent("CustomEvent")).initCustomEvent(t,!0,!0);window.dispatchEvent(n)}));const nav=new Navigation(document.querySelector(".w-main-nav"));window.navigation=nav,WebFont.load({typekit:{id:"phg5cnq"},active:()=>{nav.init(),nav.focusNavItemByIndex(0);var e=document.createEvent("HTMLEvents");e.initEvent("change",!0,!1),navToggle.dispatchEvent(e)}});